#include <Arduino.h>
#include <HardwareSerial.h>
#include <ESPAsyncWebServer.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "SPIFFS.h"

/*
	0 - No Debug
	1 - Low information
	2 - Full information
*/
#define DEBUG_LEVEL		1

// objects
Adafruit_SSD1306 display(128, 64, &Wire, -1);
AsyncWebServer server(80);
HardwareSerial SerialPort(2);

// Wifi settings
const char* ssid = "ROBOTECH";
const char* password = "vaeG7nmt";
String clientIP = "";
String serverIP = "NONE";
String state = "disconnected!";

// Hardware variables
const int ledPin = 2;
uint8_t direction;
float speed;
uint8_t rotate_angle;

// UART variables
uint8_t modbus_str_start_frame[] = { 0x0A, 0x10, 0x00, 0x01, 0x00, 0x02, 0x06, 0x00, 0x00, 
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x0A };
uint8_t modbus_str_crc_frame[] = { 0x00, 0x00 };
unsigned long time_period = 100;
unsigned long prev_time = 0;
bool isControlled_by_operator = false;

static unsigned char CRCHi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
}; 

static char CRCLo[] = {
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

void visualise_state_on_display(void)
{
	display.clearDisplay();
	display.setCursor(0, 10);
	display.print("IP:");
	display.print(WiFi.localIP());
	display.setCursor(0, 20);
	display.print("State:" + state);
	display.display();
}

void calc_crc16(unsigned char *puchmsg, unsigned short usDataLen) {
	// low high crc bytes initialized
	unsigned char uchCRCHi = 0xFF;
	unsigned char uchCRCLo = 0xFF;

	unsigned index;
	while(usDataLen--) {
		index = uchCRCHi ^ *puchmsg++;
		uchCRCHi = uchCRCLo ^ CRCHi[index];
		uchCRCLo = CRCLo[index];
	}
	modbus_str_crc_frame[0] = uchCRCLo;
	modbus_str_crc_frame[1] = uchCRCHi;
}

void send_to_stm32_modbus_frame(float tmp_speed_float, uint8_t state) {
	// IEEE 754 convert float -> uint32_t -> uint8_t buffer
	uint32_t tmp_speed_uint32_t = 0;

	memcpy(&tmp_speed_uint32_t, &tmp_speed_float, sizeof(tmp_speed_float));
#if (DEBUG_LEVEL == 2)
	Serial.println("Raw speed " + String(tmp_speed_uint32_t));
#endif
	modbus_str_start_frame[7] = ((uint8_t)((tmp_speed_uint32_t >> 24)&0xFF));
	modbus_str_start_frame[8] = ((uint8_t)((tmp_speed_uint32_t >> 16)&0xFF));
	modbus_str_start_frame[9] = ((uint8_t)((tmp_speed_uint32_t >> 8)&0xFF));
	modbus_str_start_frame[10] = ((uint8_t)(tmp_speed_uint32_t&0xFF));
	modbus_str_start_frame[11] = state;
	modbus_str_start_frame[12] = rotate_angle;
	unsigned char *ptr = modbus_str_start_frame;

	// result example: 3.33 m/s speed to ----> 0x40551eb8 (float -> uint32_t)
	// modbus frame example: 0x0A (: start char) 0x01 (01 devide ) 0x10 (10 write command) 
	// 0x06 (6 bytes uint32_t) 0x40551eb8 (3.33 speed 4 byte)
	// crc (calc crc) + 0x0D0A (char symbols /r/n)
	calc_crc16(ptr, sizeof(modbus_str_start_frame) - 4);
	memcpy(&modbus_str_start_frame[13], &modbus_str_crc_frame[0], sizeof(modbus_str_crc_frame));

#if (DEBUG_LEVEL == 2)
	Serial.println("[LOOP] Speed - " + String(speed));
	Serial.print("[LOOP] ModBus frame ");
	for(int i = 0; i < sizeof(modbus_str_start_frame); i++){
		Serial.print(String(modbus_str_start_frame[i]) + " ");
	}
	Serial.print("\r\n[LOOP] CRC - " + String(modbus_str_crc_frame[0]));
	Serial.println(" " + String(modbus_str_crc_frame[1]));
#endif
	// ToDo... collect frame + crc + endframe
	// SerialPort.write(buffer) if Serial is available
	// sending buffer like this: 0A 01 06 04 (exm. 40 55 1e b8) (crcHi crcLo) 0D 0A
#if (DEBUG_LEVEL >= 1)
	Serial.print("[LOOP] Message - ");
	for(int i = 0; i < sizeof(modbus_str_start_frame); i++) {
		Serial.print(" " + String(modbus_str_start_frame[i]));
	}
	Serial.print("\r\n");
#endif
	uint32_t time = 0xFF;
	while(SerialPort.available())
	{
		if(--time == 0) break; 
	}
#if (DEBUG_LEVEL >= 1)
		Serial.print("[LOOP] Send message \r\n");
#endif
	SerialPort.write(modbus_str_start_frame, sizeof(modbus_str_start_frame));
}

bool isOperator = false;
String processor(const String& var){
  if(var == "SWITCH"){
	if(!isOperator) {
		if(clientIP != "")
		{
			return "<label class=\"switch\"><input type=\"checkbox\" onchange=\"getControlled(this)\" disabled checked><span class=\"slider\"></span></label>";
		} else 
		{
			return "<label class=\"switch\"><input type=\"checkbox\" onchange=\"getControlled(this)\" disabled><span class=\"slider\"></span></label>";
		}
	} else {
		if(clientIP != "")
		{
			return "<label class=\"switch\"><input type=\"checkbox\" onchange=\"getControlled(this)\" checked><span class=\"slider\"></span></label>";	
		} else 
		{
			return "<label class=\"switch\"><input type=\"checkbox\" onchange=\"getControlled(this)\"><span class=\"slider\"></span></label>";	
		}	
	}
  }
  return String();
}

void setup() {
	// Serial connection
	pinMode(ledPin, OUTPUT);
	Serial.begin(115200);
	SPIFFS.begin(true);

	if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) Serial.println("SSD1306 allocation failed");
	display.setTextSize(1);
	display.setTextColor(WHITE);

	SerialPort.begin(115200, SERIAL_8N1, 16, 17);
	// Wifi connection
	WiFi.mode(WIFI_STA);
	WiFi.begin(ssid, password);
	Serial.print("[CORE] Connecting to WiFi..");
	while(WiFi.status() != WL_CONNECTED)
	{
		delay(500);
		Serial.print(".");
	}

	Serial.println("\r\n[CORE] WiFi connected!");
	Serial.println(WiFi.localIP());

	visualise_state_on_display();
   server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
		if(String(request->client()->remoteIP()) == clientIP || clientIP == "") isOperator = true;
		else isOperator = false;
		request->send(SPIFFS, "/index.html", String(), false, processor);
  });
  
  // URL для файла «style.css»:
  server.on("/style.css", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SPIFFS, "/style.css", "text/css");
  });

  // URL для файла «style.css»:
  server.on("/rcr", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SPIFFS, "/rcr.jpg", "image/jpg");
  });

  server.on("/update", HTTP_POST, [](AsyncWebServerRequest *request){
	String newState, sliderState, pos_angle;

	if(request->hasParam("operator")) {
		int isControl = request->getParam("operator")->value().toInt();
		if(isControl == 0) { 
			clientIP = ""; 
			digitalWrite(ledPin, LOW);
			Serial.print("[SERVER] Disconnected from operator with IP: "); 
			speed = 1.00;
			direction = 0;
			Serial.println(request->client()->remoteIP()); 
			state = "disconnected!";
			visualise_state_on_display();
			}
		else { 
			clientIP += request->client()->remoteIP();
			Serial.print("[SERVER] Connected control from operator with IP: ");
			Serial.println(request->client()->remoteIP()); 
			digitalWrite(ledPin, HIGH); 
			state = "connected!";
			visualise_state_on_display();
			}
	}

	if(String(request->client()->remoteIP()) == clientIP) {
		if(request->hasParam("state")) {
			newState = request->getParam("state")->value();
#if (DEBUG_LEVEL >= 1)
			Serial.println("[SERVER] New state - " + newState);
#endif
			direction = newState.toInt();
		}

		if(request->hasParam("speed")) {
			sliderState = request->getParam("speed")->value();
#if (DEBUG_LEVEL >= 1)
			Serial.println("[SERVER] Slider state - " + sliderState);
#endif
			speed = sliderState.toFloat();
		}

		if(String(request->client()->remoteIP()) == clientIP) {
			if(request->hasParam("pos")) {
				pos_angle = request->getParam("pos")->value().toInt();
#if (DEBUG_LEVEL >= 1)
			Serial.println("[SERVER] Rotate angle - " + pos_angle);
#endif
			rotate_angle = pos_angle.toInt();
			}
		}
	}
  });
  // deploy server
  server.begin();
}

void loop() {
	unsigned long tmp = millis();
	if(clientIP != "")
	{
		if(tmp - prev_time >= time_period)
		{
#if (DEBUG_LEVEL == 2)
			Serial.println("[LOOP] Time period changed ");
#endif
			prev_time = tmp;
			send_to_stm32_modbus_frame(speed, direction);
		}
	} else prev_time = tmp; 
	delay(250);
}